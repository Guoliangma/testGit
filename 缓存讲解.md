
## 1.缓存的概念 ##
	数据交换的缓冲区,临时存储数据要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，
    找不到的话则从真实数据源中找。由于缓存的运行速度快得多，故缓存的作用就是帮助系统更快地运行。

	
	缓存命中:在cache中存在用户请求的key
	未命中:不存在请求的key

## 2.缓存的种类  ##
	1. LocalCache(独立式): 例如Ehcache
	(1) 缓存和应用在一个JVM中。
	(2) 缓存间是不通信的，独立的。

	2. Standalone(单机): 
	(1) 缓存和应用是独立部署的。
	(2) 缓存可以是单台。（例如memcache/redis单机等等）
	(3) 跨进程、跨网络
	
	
	3. Distributed(分布式)：例如Redis-Cluster, memcache集群等等
	(1) 缓存和应用是独立部署的。
	(2) 多个实例。（例如memcache/redis等等）
	(3) 高可用。
	(4) 跨进程、跨网络
	
	4. Replicated(复制式): 缓存数据时同时存放在多个应用节点的，数据复制和失效的事件以同步或者异步的形式在各个集群节点间传播。（也是弱一致性）

		这种用的不太多。
		
## 3.缓存的优点 ##
	快速的读取数据,因为缓存通常都是全内存的系统,而后端都有速度慢和抗压能力差的特性，通过缓存的使用可以有效的提高用户的访问速度同时优化了用户的体验。
	降低后端和数据库的负载  后端减少访问量
	
	缺点:可能造成数据不一致  
	代码维护成本  代码就会在原数据源基础上加入缓存的相关代码
	
## 4.缓存更新策略: ##
	(1) LRU/LFU/FIFO算法剔除   
   
	FIFO(first in first out)
	先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，
	以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择
	该类策略，优先保障最新数据可用。

	LFU(less frequently used)
	最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略
	算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。

	LRU(least recently used)
	最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释
	放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。
	算法不需要开发者自己来实现，通常只需要配置最大maxmemory和对应的策略即可开发者只需要有这个东西，
	知道是什么意思，选择自己需要的算法，算法的实现是由缓存服务器实现的。

	(2)超时剔除  即设置缓存的过期时间,在缓存失效后即从真实数据源获取数据,重新放到缓存中,继续设置过期时间
	
	一段时间内存在数据一致性的问题(即数据已经更新,但是缓存还没有失效)
	成本不高,即设置过期时间即可

	(3)
	主动更新
	数据一致性要求非常高 需要真实数据更新后 缓存立即更新
	可以想象一致性最高（几乎接近强一致），但是有个问题：如果主动更新发生了问题，那么这条数据很可能很长时间不会更新了（所以可以结合超时剔除一起使用）
	
	 成本相当高，用户需要自己来完成更新（需要一定量的代码，从某种程度上加大了系统的复杂性），需要自己检查数据是否真的更新了之类的工作。
	 
## 5.缓存常用概念 ##
	
	(1)缓存穿透
		缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，并且出于容错考虑， 
		如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都
		要到存储层去查询，失去了缓存的意义。对底层数据源压力过大，有些底层数据
		源不具备高并发性。
	 
	 解决方法:1.缓存空数据
			适用场景:数据命中不高  数据频繁变化实时性高
			出现问题:占用了较多的内存空间(数量多)会有一段时间数据不一致
			(访问数据  --未找到数据  缓存空值--插入了数据--缓存未更新或者过期 导致下次访问拿到空值) 
			 解决方式:较短的过期时间,或者更新数据时主动更新缓存
			
	(2)缓存雪崩
	   缓存由于某些原因在同一时间集体失效,所有的请求都会直接指向真实数据源,导致真实数据源服务器扛不住压力
	
	   解决方法:保证cache的高可用性,即使个别的缓存挂掉,剩下的缓存依旧运行,只有部分的流量到了后端
			    设置缓存永不过期
## 6.缓存四种模式 ##
	
	(1)Cache Aside Pattern

	失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
	命中：应用程序从cache中取数据，取到后返回。
	更新：先把数据存到数据库中，成功后，再让缓存失效或者删除缓存。	
	(备注,先更新在删除的顺序,为了避免在并发情况下,A线程执行更新操作,删除数据库数据->B线程查询,缓存
	 没有拿到数据->数据库中拿到旧数据并放入缓存->A线程往数据库插入新数据->缓存中一直存在旧数据)
	(更新缓存会导致,两个并发的写操作导致脏数据。)

	(2)Read Through
	Read Through 套路就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），
	Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。

	(3)Write Through
	Write Through 套路和Read Through相仿，不过是在更新数据时发生。当有数据更新的时候，如果没有命中缓存，
	直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）
	
	(4)Write behind caching
	在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。
	
## 7.ehcache ##
	
	Ehcache的CacheManager构造函数或工厂方法被调用时，会默认加载classpath下名为ehcache.xml的配置文件。 
	如果加载失败，会加载Ehcache jar包中的ehcache-failsafe.xml文件，这个文件中含有简单的默认配置。 



    public class EhcacheTest {

    public static void main(String[] args) {
        //1.创建缓存管理器
        CacheManager cacheManager = new CacheManager(new EhcacheTest().getClass().getClassLoader().getResourceAsStream("/ehcache.xml"));
        
        //手动增加ehcache的实例
	//      CacheConfiguration c1 = new CacheConfiguration();
	//      c1.setName("ehcahe_test2");
	//      c1.setMaxElementsInMemory(1000);
	//      Cache che2 = new Cache(c1);
	//      cacheManager.addCache(che2);
        //2.获取缓存对象
        Cache cache = cacheManager.getCache("ehcache_test");
        
        //编程式设置缓存参数
      CacheConfiguration cacheConf = cache.getCacheConfiguration();
      cacheConf.setTimeToIdleSeconds(60); 
      cacheConf.setTimeToLiveSeconds(120); 
      cacheConf.setMaxEntriesLocalHeap(10000);
      cacheConf.setMaxEntriesLocalDisk(1000000);
        //3.创建缓存元素
        String test_key = "王小六";
        Element element = new Element(test_key, new UserInfo("王小六","6789@jkl"));
    
        //4将元素添加到缓存中
        cache.put(element);
        System.out.println("将"+element.getKey()+"添加到缓存中");
        
        System.out.println("---------------");
        
        //5从缓存中获取元素
        Element value = cache.get(test_key);
        System.out.println(value.getObjectKey());
        System.out.println(value.getObjectValue());
        
        //6.删除元素
        cache.remove(test_key);
        //7.刷新缓存
        cache.flush();
        //8.再次尝试获取key
        Element value_test = cache.get(test_key);
        System.out.println(value_test);
        
        
        // 8. 关闭缓存管理器
        cacheManager.shutdown();
    }
	}


	
## 8:spring整合 ##
	Spring 提供了对缓存功能的抽象：即允许绑定不同的缓存解决方案（如Ehcache），但本身不直接提供缓存功能的实现。
	它支持注解方式使用缓存，非常方便。

	package com.cache.ehcache.spring.service;


	@Service
	public class EhcacheService implements IEhcacheService {

    // value的值和ehcache.xml中的配置保持一致
    
    /**
     *  Cacheable表明所修饰的方法是可以缓存的  
     *  表明所修饰的方法是可以缓存的：当第一次调用这个方法时，它的结果会被缓存下来，在缓存的有效时间内，以后访问这个方法都直接返回缓存结果，不再执行方法中的代码段。 
     *  value：缓存位置名称，不能为空，如果使用EHCache，就是ehcache.xml中声明的cache的name, 指明将值缓 存到哪个Cache中
     *  key：缓存的key，默认为空，既表示使用方法的参数类型及参数值作为key,如果要引用参数值使用井号加参数名
     *  condition：触发条件，只有满足条件的情况才会加入缓存，默认为空，既表示全部都加入缓存
   	 * @param param
     * @return
     */
    @Override
    @Cacheable(value="ehcache_test", key="#param")
    public String getTimestamp(String param) {
        System.out.println("方法体被执行了");
        Long timestamp = System.currentTimeMillis();
        return timestamp.toString();
    }
    @Override
    @Cacheable(value="ehcache_test", key="#key")
    public String getDataFromDB(String key) {
        System.out.println("从数据库中获取数据...");
        return key + ":" + String.valueOf(Math.round(Math.random()*1000000));
    }
    @Override
    @CacheEvict(value="ehcache_test", key="#key")
    public void removeDataAtDB(String key) {
        System.out.println("从数据库中删除数据");
    }
    
    
    /**
     * CachePut执行更新操作，它支持的属性和用法都与@Cacheable一致。
     * @param key
     * @return
     */
    @Override
    @CachePut(value="ehcache_test", key="#key")
    public String refreshData(String key) {
        System.out.println("模拟从数据库中加载数据");
        return key + "::" + String.valueOf(Math.round(Math.random()*1000000));
    }

    // ------------------------------------------------------------------------
    @Override
    @Cacheable(value="UserCache", key="#UserInfoId")    
    public UserInfo findById(String UserInfoId) {  
        System.out.println("模拟从数据库中查询数据");
        return (UserInfo) new UserInfo("1", "t");           
    }  
    @Override
    @Cacheable(value="UserCache", condition="#UserInfoId.length()<12")    
    public boolean isReserved(String UserInfoId) {    
        System.out.println("UserInfoCache:"+UserInfoId);    
        return false;    
    }

    //清除掉UserInfoCache中某个指定key的缓存    
    /**
      * CacheEvict表明所修饰的方法是用来删除失效或无用的缓存数据。
     * value：缓存位置名称，不能为空，同上
     * key：缓存的key，默认为空，同上
     * condition：触发条件，只有满足条件的情况才会清除缓存，默认为空，支持SpEL
     * allEntries：true表示清除value中的全部缓存，默认为false
     * @param UserInfoId
     */
    @Override
    @CacheEvict(value="UserCache",key="#UserInfoId")    
    public void removeUserInfo(String UserInfoId) {    
        System.out.println("UserInfoCache remove:"+ UserInfoId);    
    }    

    //清除掉UserInfoCache中全部的缓存    
    @Override
    @CacheEvict(value="UserCache", allEntries=true)    
    public void removeAllUserInfo() {    
       System.out.println("UserInfoCache delete all");    
    }
	}


--

	@RunWith(SpringJUnit4ClassRunner.class)
	@ContextConfiguration(locations = { "classpath*:pro/spring-*.xml"})
	public class EhcacheSpringTest extends AbstractJUnit4SpringContextTests {
    
    @Autowired
    private IEhcacheService ehcacehService;
    
    
    @Test
    public void testTimestamp() throws InterruptedException{
        System.out.println("第一次调用：" + ehcacehService.getTimestamp("param"));
        Thread.sleep(2000);
        System.out.println("2秒之后调用：" + ehcacehService.getTimestamp("param"));
        Thread.sleep(4000);
        System.out.println("再过4秒之后调用：" + ehcacehService.getTimestamp("param"));
    }

    @Test
    public void testCache(){
        String key = "zhangsan";
        String value = ehcacehService.getDataFromDB(key); // 从数据库中获取数据...
        ehcacehService.getDataFromDB(key);  // 从缓存中获取数据，所以不执行该方法体
        ehcacehService.removeDataAtDB(key); // 从数据库中删除数据
        ehcacehService.getDataFromDB(key);  // 从数据库中获取数据...（缓存数据删除了，所以要重新获取，执行方法体）
    }

    @Test
    public void testPut(){
        String key = "testData";
        ehcacehService.refreshData(key);  // 模拟从数据库中加载数据
        String data = ehcacehService.getDataFromDB(key);
        System.out.println("data:" + data); // 

        ehcacehService.refreshData(key);  // 模拟从数据库中加载数据
        String data2 = ehcacehService.getDataFromDB(key);
        System.out.println("data2:" + data2);   // 
    }


    @Test
    public void testIsReserved(){
        String itrA = "133";
        String itrB  = "12333333333333333333333333333";
        ehcacehService.isReserved(itrB);
        
        ehcacehService.isReserved(itrB);
    }

    @Test
    public void testRemoveUser(){
        // 线添加到缓存
        ehcacehService.findById("1");

        // 再删除
        ehcacehService.removeUserInfo("1");

        // 如果不存在会执行方法体
        ehcacehService.findById("1");
    }

    @Test
    public void testRemoveAllUser(){
        ehcacehService.findById("1");
        ehcacehService.findById("2");

        ehcacehService.removeAllUserInfo();
	 // ehcacehService.removeUserInfo("1");
        
        ehcacehService.findById("1");
        ehcacehService.findById("2");

    }


 	}

	
	

参考资料
	
https://coolshell.cn/articles/17416.html

https://www.cnblogs.com/mushroom/p/4199701.html

http://carlosfu.iteye.com/blog/2269678

	


	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	