# 单点登录(Single Sign On)

## 一、产生背景
- web系统早已从久远的单系统发展成为如今由多系统组成的应用群，面对如此众多的系统，用户难道要一个一个登录、然后一个一个注销吗？

![avatar](http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155236162-1706551789.png)

- 好的web系统复杂性应该由系统内部承担，而不是用户。无论web系统内部多么复杂，对用户而言，都是一个统一的整体，也就是说，用户访问web系统的整个应用群与访问单个系统一样，登录/注销只要一次就够了。

![avatar](http://images2015.cnblogs.com/blog/797930/201611/797930-20161129155237240-1462133891.png)

- 一次登录的需求在早期是通过cookie来实现，但是后面因为需要保持应用群域名一致及应用群使用的技术一致等诸多限制，逐渐改为由单点登录来实现。

## 二、相关知识
### Http
- 众所周知，HTTP 是一个无状态协议，所以客户端每次发出请求时，下一次请求无法得知上一次请求所包含的状态数据，如何能把一个用户的状态数据关联起来呢？
比如在淘宝的某个页面中，你进行了登陆操作。当你跳转到商品页时，服务端如何知道你是已经登陆的状态？

### Cookie
- 首先产生了 cookie 这门技术来解决这个问题，cookie 是 http 协议的一部分，它的处理分为如下几步：

    1.服务器向客户端发送 cookie。

    2.通常使用 HTTP 协议规定的 set-cookie 头操作。

    3.规范规定 cookie 的格式为 name = value 格式，且必须包含这部分。

    4.浏览器将 cookie 保存。

    5.每次请求浏览器都会将 cookie 发向服务器。
    
    ps：cookie是通过域来区分归属的，不同的服务器的cookie信息是独立的

### Session
- cookie 虽然很方便，但是使用 cookie 有一个很大的弊端，cookie 中的所有数据在客户端就可以被修改，数据非常容易被伪造，那么一些重要的数据就不能存放在 cookie 中了，而且如果 cookie 中数据字段太多会影响传输效率。为了解决这些问题，就产生了 session，session 中的数据是保留在服务器端的。
- session 的运作通过一个session_id来进行。session_id通常是存放在客户端的 cookie 中，当请求到来时，服务端检查 cookie 中保存的 session_id 并通过这个 session_id 与服务器端的 session data 关联起来，进行数据的保存和修改。

### Token
- 传统的身份验证方法从最早的cookie到session以及给session cookie做个加密，接下来我们来看看token认证。
- 简单点来说，token认证就是不用每一次请求都提供用户名和密码的凭证。客户端第一次访问，验证身份通过后生成一个Token返回给客户端存在本地。Token通常比密码更加长而且复杂。一旦获得了token，在每次调用API的时候都要附加上它。然后，这仍然比直接发送账户和密码更加安全，哪怕是HTTPS。
把token想象成一个安全的护照。你在一个安全的前台验证你的身份（通过你的用户名和密码），如果你成功验证了自己，你就可以取得这个。当你走进大楼的时候（试图从调用API获取资源），你会被要求验证你的护照，而不是在前台重新验证。

## 三、单点登录原理
### 1、登录

![avatar](https://images2015.cnblogs.com/blog/797930/201612/797930-20161203152650974-276822362.png)

1.用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

2.sso认证中心发现用户未登录，将用户引导至登录页面

3.用户输入用户名密码提交登录申请

4.sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌

5.sso认证中心带着令牌跳转会最初的请求地址（系统1）

6.系统1拿到令牌，去sso认证中心校验令牌是否有效

7.sso认证中心校验令牌，返回有效，注册系统1

8.系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源

9.用户访问系统2的受保护资源

10.系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数

11.sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌

12.系统2拿到令牌，去sso认证中心校验令牌是否有效

13.sso认证中心校验令牌，返回有效，注册系统2

14.系统2使用该令牌创建与用户的局部会话，返回受保护资源

- 用户登录成功之后，会与sso认证中心及各个子系统建立会话，用户与sso认证中心建立的会话称为全局会话，用户与各个子系统建立的会话称为局部会话，局部会话建立之后，用户访问子系统受保护资源将不再通过sso认证中心，全局会话与局部会话有如下约束关系：

    局部会话存在，全局会话一定存在

    全局会话存在，局部会话不一定存在

    全局会话销毁，局部会话必须销毁

### 2、注销
单点登录自然也要单点注销，在一个子系统中注销，所有子系统的会话都将被销毁

![avatar](http://p3.pstatp.com/large/1243000632f89db69dbb)


## 四、简单实现
### sso-client

#### 拦截子系统未登录用户请求，跳转至sso认证中心

```
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    HttpSession session = req.getSession;
    
    if (session.getAttribute("isLogin")) {
        chain.doFilter(request, response);
        return;
    }
    //跳转至sso认证中心
    res.sendRedirect("sso-server-url-with-system-url");
}  
```

#### 接收并存储sso认证中心发送的令牌
- sso认证中心登录后，跳转回子系统并附上令牌，子系统（sso-client）取得令牌，然后去sso认证中心校验，在LoginFilter.java的doFilter中添加几行
```
// 请求附带token参数
String token = req.getParameter("token");
if (token != null) {
    // 去sso认证中心校验token
    boolean verifyResult = this.verify("sso-server-verify-url", token);
    if (!verifyResult) {
        res.sendRedirect("sso-server-url");
        return;
    }
    //登录成功，保存token到cookie中
    CookieUtils.setCookie(request, response, COOKIE_NAME, token);
    chain.doFilter(request, response);
} 
```

#### 与sso-server通信，校验令牌的有效性
方式多种多样，sso-server开放个接口检验即可，服务端查到令牌存在并且在有效期内即可

#### 建立局部会话
```
if (verifyResult) {
    session.setAttribute("isLogin", true);
    //同时将token和session绑定，方便后面接收SSOServer的请求注销对应session
}  
```

#### 拦截用户注销请求，向sso认证中心发送注销请求
```
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    HttpServletResponse res = (HttpServletResponse) response;
    HttpSession session = req.getSession;
    
    //从cookie中取出token
    String token=CookieUtils.getToken();
    //向sso-server发送注销请求
    logout（sso-server-logout-url，token）;
}  
```

#### 接收sso认证中心发出的注销请求，销毁局部会话
```
@RequestMapping("/logout")
public String logout(HttpServletRequest req) {
  String token = req.getParameter("token");
  //通过token找到对应的session来注销
} 
```

### sso-server

#### 验证用户的登录信息
```
@RequestMapping("/login")
public String login(String username, String password, HttpServletRequest req) {
    this.checkLoginInfo(username, password);
    req.getSession.setAttribute("isLogin", true);
    return "success";
} 
```

#### 创建全局会话
某种意义上来说就是一个特殊的局部回话，实现方式有多种，很多时候和局部回话一样

#### 创建授权令牌

- 授权令牌是一串随机字符，以什么样的方式生成都没有关系，只要不重复、不易伪造即可，下面是一个例子
```
String token = UUID.randomUUID.toString;
```

与sso-client通信发送令牌

#### 校验sso-client令牌有效性
- 用户在sso认证中心登录成功后，sso-server创建授权令牌并存储该令牌，所以，sso-server对令牌的校验就是去查找这个令牌是否存在以及是否过期，令牌校验成功后sso-server将发送校验请求的系统注册到sso认证中心（就是存储起来的意思）

- 令牌与注册系统地址通常存储在key-value数据库（如redis）中，redis可以为key设置有效时间也就是令牌的有效期。redis运行在内存中，速度非常快，正好sso-server不需要持久化任何数据。

- 可能你会问，为什么要存储这些系统的地址？如果不存储，注销的时候就麻烦了，用户向sso认证中心提交注销请求，sso认证中心注销全局会话，但不知道哪些系统用此全局会话建立了自己的局部会话，也不知道要向哪些子系统发送注销请求注销局部会话
![avatar](https://images2015.cnblogs.com/blog/797930/201611/797930-20161129155245506-1069288802.png)


#### 接收sso-client注销请求，注销所有会话
```
public class LogoutListener implements HttpSessionListener {
    @Override
    public void sessionCreated(HttpSessionEvent event) {}
    @Override
    public void sessionDestroyed(HttpSessionEvent event) {
        //通过httpClient向所有注册系统发送注销请求
    }
} 
```

##参考资料
- https://blog.csdn.net/u011277123/article/details/53404269