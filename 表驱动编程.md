# 定义
表驱动法是一种编程模式，从表里查找信息，而不是使用逻辑语句（if和else）

# 直接访问表
直接得到，可以用数组，Map等数据结构快速查找

## eg:
- 每月的天数
- 通达海中的单位代码和绩效系统中的代码对应


```
    private static HashBiMap<String, String> relation = HashBiMap.create();
    
    static {
        relation.put("3077", "511021");
        relation.put("3132", "513321");
        relation.put("3079", "511025");
        relation.put("3137", "513325");
        relation.put("3135", "513324");
        relation.put("3134", "513323");
        relation.put("3078", "511024");
        relation.put("3133", "513322");
        relation.put("3061", "510728");
    }
```


# 索引访问
如同书的目录、数据库索引

## eg
将数据库中数据（list）转换为Map格式，方便使用，提高性能

```
    //查询每个人的工作量
	public Map<String, BigDecimal> getUserGzlMap(String corpId, Date start, Date end) {
		Map<String, BigDecimal> gzlMap = new HashMap<String, BigDecimal>();
		String sqlTemplate = "select ry.c_ry as user,sum(ry.n_rygzl) as qzdf from db_gzlpg."
				+ tableRouter.getTableName("t_gzl_aj", corpId) + " aj,db_gzlpg."
				+ tableRouter.getTableName("t_gzl_aj_ry", corpId)
				+ " ry where aj.n_ajbs=ry.n_ajbs and d_jarq >=? and d_jarq <=? and (aj.n_hylx != 0 or aj.n_hylx is null) and aj.n_gzllx is not null  and ry.n_js = 255 group by ry.c_ry";
		List<Map<String, Object>> result = jdbcTemplate.queryForList(sqlTemplate, new Object[] { start, end });
		for (Map<String, Object> record : result) {
			String ryId = (String) record.get("user");
			BigDecimal qzdf = (BigDecimal) record.get("qzdf");
			if (qzdf == null) {
				qzdf = new BigDecimal(0);
			}
			gzlMap.put(ryId, qzdf);
		}
		return gzlMap;
	}
```

# 阶梯访问

```
    #define MAX_GRADE_LEVEL   (INT8U)5
    DOUBLE aRangeLimit[MAX_GRADE_LEVEL] = {50.0, 60.0, 70.0, 80.0, 100.0};
    CHAR *paGrades[MAX_GRADE_LEVEL] = {"Fail", "Pass", "Credit", "Distinction", "High Distinction"};

    static CHAR* EvaluateGrade(DOUBLE dScore){
        INT8U ucLevel = 0;
         for(; ucLevel < MAX_GRADE_LEVEL; ucLevel++)
         {
             if(dScore < aRangeLimit[ucLevel])
                 return paGrades[ucLevel];
         }
         return paGrades[0];
    }
```


# 场景
四川高院从最高法院查询再审审查案件，对于特定类型的案件保存到本地数据库

返回的数据为json

返回数据示例：
```
[
    {
        N_JAFS	"2"
        C_YSQKAH	"(2013)川民终字第766号"
        N_YSQKSPCX	"2"
        N_XAJLY	"2"
        N_YSQKJAFS	"2"
        D_LARQ	"2016-05-23 00:00:00.0"
        D_YSQKJARQ	"2014-07-08 00:00:00.0"
        D_SXRQ	"2017-07-18 00:00:00.0"
        N_XJAFS	"2"
        N_YSQKXH	"2"
        N_AJBS	"1061000000000074631"
        C_AH	"(2016)最高法民申1222号"
        N_ZSSCAJZLB	"2"
        N_YSQKJBFY	"3000"
    },
    {
        N_JAFS	"2"
        C_YSQKAH	"(2012)雅民初字第00090号"
        N_YSQKSPCX	"1"
        N_XAJLY	"2"
        N_YSQKJAFS	"1"
        D_LARQ	"2016-05-23 00:00:00.0"
        N_YSQKAJLB	"2"
        D_YSQKLARQ	"2012-07-06 00:00:00.0"
        D_YSQKJARQ	"2013-10-17 00:00:00.0"
        D_SXRQ	"2017-07-18 00:00:00.0"
        N_XJAFS	"2"
        N_AJBS	"1061000000000074631"
        C_AH	"(2016)最高法民申1222号"
        N_ZSSCAJZLB	"2"
        N_YSQKJBFY	"3122"
    }
]
```


判断条件如下：
- 再审审查案件来源_2015=1,案件子类别=1，新结案方式=3、4
- 再审审查案件来源_2015=2,案件子类别=1，新结案方式=3、4
- 再审审查案件来源_2015=3,案件子类别=1，新结案方式=2、3
- 再审审查案件来源_2015=1,案件子类别=2，新结案方式=3、4
- 再审审查案件来源_2015=2,案件子类别=2，新结案方式=3、4
- 再审审查案件来源_2015=3,案件子类别=2，新结案方式=2、3
- 再审审查案件来源_2015=1,案件子类别=6，新结案方式=3、4
- 再审审查案件来源_2015=2,案件子类别=6，新结案方式=2、3
- 再审审查案件来源_2015=3,案件子类别=6，新结案方式=2、3

# 重构前代码

```
                if (ArrayUtils.contains(new String[] { "2", "4", "5" }, jsonobj.getString("N_JAFS"))
						&& ArrayUtils.contains(new String[] { "1", "2", "3" }, jsonobj.getString("N_XAJLY"))
						&& ArrayUtils.contains(new String[] { "1", "2", "6" }, jsonobj.getString("N_ZSSCAJZLB"))) {
					if ("3".equals(jsonobj.getString("N_JAFS"))
							|| "6".equals(jsonobj.getString("N_ZSSCAJZLB")) && "2".equals(jsonobj.getString("N_XAJLY"))
									&& "2".equals(jsonobj.getString("N_JAFS"))
							|| "1".equals(jsonobj.getString("N_XAJLY")) && "4".equals(jsonobj.getString("N_JAFS"))
							|| "3".equals(jsonobj.getString("N_XAJLY")) && "2".equals(jsonobj.getString("N_JAFS"))
							|| ("1".equals(jsonobj.getString("N_ZSSCAJZLB"))
									|| "2".equals(jsonobj.getString("N_ZSSCAJZLB")))
									&& ("2".equals(jsonobj.getString("N_XAJLY")))
									&& ("4".equals(jsonobj.getString("N_JAFS")))) {
						//logic code
					}
				}
```

# 重构后代码

## 规则

```
	private Set<String> valid=Sets.newHashSet();
	//使用Set判断满足的key集合，规则 N_XAJLY-N_ZSSCAJZLB-N_XJAFS
	{
		valid.add("1-1-3");
		valid.add("1-1-4");
		valid.add("2-1-3");
		valid.add("2-1-4");
		valid.add("3-1-2");
		valid.add("3-1-3");

		valid.add("1-2-3");
		valid.add("1-2-4");
		valid.add("2-2-3");
		valid.add("2-2-4");
		valid.add("3-2-2");
		valid.add("3-2-3");

		valid.add("1-6-3");
		valid.add("1-6-4");
		valid.add("2-6-2");
		valid.add("2-6-3");
		valid.add("3-6-2");
		valid.add("3-6-3");
	}
```


## 判断方法
```
    if(isMatch(jsonobj)){
        //logic code
    }

	private boolean isMatch(JSONObject jsonobj) {
		String ajly=jsonobj.getString("N_XAJLY");
		String ajzlb=jsonobj.getString("N_ZSSCAJZLB");
		String jafs=jsonobj.getString("N_XJAFS");
		String key=ajly+"-"+ajzlb+"-"+jafs;
		return valid.contains(key);
	}
```

# 总结
规则很规范，固定占位符上特定字段，直接Set保存满足条件组合值，利用Set的contains属性直接判断效率，代码易读，也容易修改

# 更进一步
复杂的判断建议都单独提取方法判断，不要耦合在逻辑代码中

规则从配置文件或者数据库中获取

结合分类思想，可以嵌套实现更加强大的功能

参考资料：代码大全第18章

@Auther lgwb
