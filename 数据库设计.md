# 数据库设计

### 设计工具

- SMD--公司内部数据库建模设计工具
- SMD的使用可以参考《SMD说明》

### 整体设计

- 数据库级别不设计默认值
- 业务表上不做代码值和代码名称这类的简单冗余
- 禁止使用触发器必须做增量设计，请参照《数据增量设计说明书》
- 不允许存在逻辑删除标志位，设计逻辑外键必须定义索引（公司规定禁止使用外键设计）
- 表必须有主键或唯一约束

### 建表规约

- 表名、字段名
  - 必须使用小写字母或者数字，禁止出现数字开头，禁止两个下划线中间只出现数字（反例：``xx_3_xx``）
  - 表名不使用复数
  - 主键索引名为：``pk_字段名``，唯一索引名为``uk_字段``,普通索引名为``idx_字段``,或者``i_字段``

### 索引规约

- 唯一索引

  业务上有唯一特性的字段，及时是多个字段的组合，也必须建成唯一索引，例如：

  `CREATE UNIQUE INDEX index_name ON table_name USING btree(column_name)`

- 超过三个表禁止join,需要join的字段，数据类型必须一致；当多表关联查询时，保证被关联的字段需要有索引

- 如果有order by 的场景，请注意利用索引的有序性，order by 最后的字段是组合索引的一部分，并且放在组合索引顺序的最后，例如：

  ``WHERE a=? AND b=? ORDER BY c; 索引 a_b_c``

- 避免字段的隐式转换，造成索引失效

### SQL 语句

- 不要使用count(列民)或者count(1)来替代count(*)
- 阿里规范，明确禁止使用存储过程，公司规定，建议少用；存储过程难以调试和扩展，没有移植性
- in操作，建议in里面的值在100以内，阿里规约，控制在1000以内
- 全表删除，建议使用TRUNCATE TABLE 比DELETE 速度快，且使用的系统和事物日志资源少，但是容易造成事故，使用前，一定要对重要数据进行备份
- 禁止使用not in语句、建议使用not exists
- 禁止在查询所有字段时候，使用``SELECT * ``
- 禁止使用``=NULL/!=NULL``
- LIKE %%,对于数据库来说大多数是全表扫描，建议弱化需求或改用全文检索。在abase中可以创建gin和gist索引来走索引。
- 择优选择使用exists和in，join
- ``SELECT COUNT(DISTINCT(列名))``语句非常耗性能，建议写成``SELECT COUNT(*) FROM (SELECT DISTINCT(列名))``
- 建议关键字大写，表名和列名小写。

### 分库、分表原则

- 垂直分表

  垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中。

  拆分字段的操作建议在数据库设计阶段就做好，在一定程度上避免跨页问题。

- 垂直分库

  按照业务模块来划分出不同的数据库，而不是将所有的数据表都放到同一个数据库中。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。

  切忌“过度设计”和“过早优化”，分库之后需要考虑跨库join、分布式事物等问题。

- 水平分表

  水平分表也称为横向分表，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。例如：user_0000+user_0001+...数据的集合为一份完整数据。

  水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。

- 水平分库

  水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。例如“冷热数据分离”：将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询。

  在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。

`ps`:**当单表行数超过500万行或者单表 容量超过2GB时，才推荐分库分表，如果预计三年后的数据量无法达到这个级别，请不要在创建表就分库分表**。 

### 表设计

- 范式(Normalization)

1. 第一范式

   数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。

2. 第二范式

   要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。

3. 第三范式

   在第二份范式的基础上消除传递依赖，任何非主属性不得传递依赖于主属性（例如部门和员工的一对多关系，不应设计为一张表）。

Normalization做的不够会导致数据冗余，而过度Normalization 会导致太多的join和数据表，这两种情况都会影响性能。

- 主键设计

关系数据库依赖于主键---它是数据库物理模式的基石。它用于惟一地标识一行数据，可以作为一个被其他表有效引用的对象(作为另一个表的外键)。

1. 主键应当是对用户没有意义的。
2. 主键应该是单列的，以便提高连接和筛选操作的效率（不要找借口使用复合主键）。
3. 永远也不要更新主键。


- 外键设计

保持数据一致性，完整性，主要目的是控制存储在外键表中的数据。使两张表形成关联，外键只能引用外表中的主键列！

1. 在大型系统中（性能要求不高，安全要求高），使用外键；在大型系统中（性能要求> 高，安全自己控制），不用外键；小系统随便，最好用外键。
2. 用外键要适当，不能过分追求
3. 不用外键而用程序控制数据一致性和完整性时，应该写一层来保证，然后个个应用通过这个层来访问数据库。

- 冗余设计

在设计数据库时，某一字段属于一个表，但它又同时出现在另一个或多个表，且完全等同于它在其本来所属表的意义表示，那么这个字段就是一个冗余字段。例如：订单表冗余用户昵称字段。

优点：提高查询效率，不用连表查询。

缺点：更新冗余字段时麻烦。

- 字段设计

1. 字段名称一般采用名词或动宾短语，且字段名为小写。
2. 采用有意义的字段名。
3. 在命名表的列时，不要重复表的名称。

- 增量设计

在表设计时添加创建时间、修改时间等类似字段，记录下数据状态更新的时间，数据删除时需要单独记录到另一张表，方便数据同步。

- 索引设计

索引是对数据库表中一个或多个列的值进行排序的结构。

1. 聚簇索引（CLUSTERED）

   表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。对于聚集索引，叶子结点即存储了真实的数据行，不再有另外单独的数据页。在一张表上最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。B树，放的东西就是放的真的值。

   聚集索引是一种稀疏索引，数据页上一级的索引页存储的是页指针，而不是行指针。

2. 非聚簇索引（NONCLUSTERED）

   表数据存储顺序与索引顺序无关。对于非聚集索引，叶结点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。B+树，放的是指针，指向真实的值。

   非聚簇索引是密集索引，在数据页的上一级索引页它为每一个数据行存储一条索引记录。

索引一般建立在经常搜索的列、主键列、连接的列、排序的列

不应建立索引的列:很少使用的列、数据值很少的列（例如性别，查询结果占比很大）、很大数据的列（text、image、bit等），另外修改性能>>检索性能时也不应使用索引，修改数据时会对索引进行更新。

- 索引类型

  - Btree：

  ​      Operators，>, <, >=, <=, =, BETWEEN, IN, IS NULL, IS NOT NUL ，LLIKE(开头匹配),  ILIKE (大小写一致的字符开头匹配)。

  - Hash：

  ​	Operator，=，不记录WAL, 数据库crash后如果hash索引对应的表在恢复期间做过改动, hash需要重建.hash索引不支持基于wal或流复制的standby。

  - Gin：

    <@, @>, =, %%，(key,posting list)

    例：从法标抽取的案件表，有部分数据需要去模糊匹配案号，所以果断使用了Gin索引。

  - Gist：

    数组，网络地址 ，范围。详情（http://postgres.cn/docs/9.6/gist-builtin-opclasses.html#GIST-BUILTIN-OPCLASSES-TABLE）；nearest-neighbor search；gist的特长是聚集，范围是否相交，是否包含，地理位置中的点面相交，或者按点搜索附近的点。

  - Brin：

    <，<=，=，>=，>，块范围索引（有损索引），流式数据处理，索引占用空间小

  - RUM

    gin的改进版，效率比gin更高

    参考资料：https://yq.aliyun.com/articles/68244

- 多列索引

  - Multicolumn Index

    B-Tree、Gist、Gin和Brin，默认最多可以索引32个域（可以修改）。

  - B-Tree

    B-Tree 多列索引支持任意列的组合查询，但是最有效的查询还是包含驱动列条件的查询。

  - Gist

    驱动列的选择性决定了需要扫描多少索引条目，与非驱动列无关（而B-Tree是与非驱动列也有关）。并不建议使用gist多列索引

  - Gin

    Gin多列索引支持任意列的组合查询，并且任意查询条件的查询效率都是一样的（不支持排序）。

  - Brin

    Brin多列索引支持任意列的组合查询，并且任意查询条件的查询效率都是一样的。

- 函数索引

  例子：

  ````sql
  --创建表
  CREATE TABLE test (
      id integer,
      content varchar COLLATE "x"
  );
  --建立索引
  CREATE INDEX test_content_index ON test (content);

  --走索引test_content_index
  SELECT * FROM test WHERE content > constant;

  --不走索引test_content_index
  SELECT * FROM test WHERE content > constant COLLATE "y";

  --需建立与y COLLATE对应的索引, 以上这条SQL才会走索引.
  CREATE INDEX test_content_y_index ON test (content COLLATE "y");
  ````

- 部分索引

  列子：

  ````sql
  --创建表
  CREATE TABLE test(
    id INT,
    info TEXT
  );

  --插入测试数据（共101000条）
   INSERT INTO test SELECT 1,'digoal'||generate_series(1,100000);
   INSERT INTO test SELECT generate_series(1,1000),'digoal'||generate_series(1,1000);

  --id=1, 这个值有100001条, 走索引根本不合适，partial 索引很好的避免了此类情况。
  CREATE index idx_test_1 on test(id) WHERE id <> 1 ;

  --查看执行计划，走了索引idx_test_1
  EXPLAIN 
  SELECT * FROM test WHERE id=100;
  --执行计划
  Index Scan using idx_test_1 on test  (cost=0.28..45.04 rows=1077 width=15);

  --不走索引idx_test_1
  EXPLAIN 
  SELECT * FROM test WHERE id=1;
  --执行计划
  Seq Scan on test  (cost=0.00..1791.00 rows=100000 width=15)
     Filter: (id = 1);
  ````

- 仅扫描索引

  Index Only Scan，就是所谓的覆盖索引；

  查询必须仅引用索引中存储的列。例如，给定一个也有列z的表的x和y列的索引，这些查询可以使用仅索引扫描：

  ````sql
  --Index Only Scan
  SELECT x, y FROM tab WHERE x = 'key';
  SELECT x FROM tab WHERE x = 'key' AND y < 42;
  --不能使用索引：
  SELECT x, z FROM tab WHERE x = 'key';
  SELECT x FROM tab WHERE x = 'key' AND z < 42;
  ````

- 索引快还是全表扫描快?

  取决于缓存的大小,存储的IOPS能力, 是否使用索引排序以及SQL需要发起的IO次数(索引, 离散IO. 全表扫描, 顺序IO)等。

- 是否使用索引和什么有关系

  - 是操作符是否支持对应的索引访问方法来决定的。
  - 是优化器决定的；如果走索引的成本低，可以走索引。   或者使用了开关，禁止全表扫，也可以走索引。

- 触发器、存储过程使用原则

  触发器是特殊的存储过程，它不需要参数，不需要显示调用。

  摒弃触发器，触发器的功能基本都可以用存储过程来实现。

- 存储过程的优点：

  - 可以封装数据逻辑和业务规则，方便使用。
  - 存储过程可通过将多个操作组合到一个过程调用中来减少网络通讯，减少网络IO。
  - 安全性好，可以访问执行存储过程而不必拥有直接操作基础表的权限。
  - 执行快速，编译好之后存储在高速缓存中，用于再次调用。

- 存储过程的缺点：

  - 可移植性查。
  - 开发调试困难。
  - 没办法应用缓存。
  - 不支持群集，数据库服务器无法水平扩展，或者数据库的切割（水平或垂直切割）。数据库切割之后，存储过程并不清楚数据存储在哪个数据库中。

总结：

1. 适当的使用存储过程，能够提高我们SQL查询的性能，
2. 存储过程不应该大规模使用，滥用。
3. 随着众多ORM 的出现，存储过程很多优势已经不明显。
4. SQL最大的缺点还是SQL语言本身的局限性——SQL本身是一种结构化查询语言，我们不应该用存储过程处理复杂的业务逻辑——让SQL回归它“结构化查询语言”的功用。复杂的业务逻辑，还是交给代码去处理吧。